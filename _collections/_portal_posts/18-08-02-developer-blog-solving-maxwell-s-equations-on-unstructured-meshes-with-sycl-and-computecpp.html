---
id: 309
url: 08-02-18-developer-blog-solving-maxwell-s-equations-on-unstructured-meshes-with-sycl-and-computecpp
user_id: 840
date: 2018-08-02T11:47:12.7200Z
category: blogs
title: "Developer Blog - Solving Maxwell's Equations on Unstructured Meshes with SYCL and ComputeCpp"
showOnFrontPage: 0
views: 0
tags:
redirect_from:
  - /portal/08-02-18-developer-blog-solving-maxwell-s-equations-on-unstructured-meshes-with-sycl-and-computecpp
thumbnail: /assets/images/portal/article-images/79092e9039b95f1316af1662e4646667.jpg
layout: portal/portal-article-view
---
<span data-trumbowyg-textnode="">Ayesha Afzal and Christian Schmitt are based at Friedrich-Alexander-Universit√§t and part of a team working on the "<a href="http://www.highpermeshes.info/">HighPerMeshes</a>" research project, a collaborative research project funded by German Ministry of Education and Research (BMBF).</span><br><br><span data-trumbowyg-textnode="">The project team decided to use SYCL to develop the code for their research because it allowed them to write modern C++ code that can be deployed to a range of heterogeneous hardware.</span><br><br><div><span data-trumbowyg-textnode="">Christian has written the following post about their project and how the team used SYCL to make it a success.<br></span></div><div><br></div><div><img src="{{ '/assets/images/portal/article-images/605f65bf69a18c91dd1781b5e23f62a1.jpg' | relative_url }}" width="301" height="301"><img src="{{ '/assets/images/portal/article-images/31ca9f852329de1c5f5a4314db47fbdf.jpg' | relative_url }}" width="301" height="301"></div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Christian Schmitt&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Ayesha Afzal</div><div><br></div><div><br><span data-trumbowyg-textnode=""></span></div><div><h3><span data-trumbowyg-textnode="">Solving Maxwell's Equations on Unstructured Meshes with SYCL and ComputeCpp</span></h3></div><div><strong><span data-trumbowyg-textnode=""><br></span></strong></div><div><span data-trumbowyg-textnode="">Maxwell's equations form the foundation for electric, optical, and radio technologies, and thus are widely used in research and engineering.</span></div><div><span data-trumbowyg-textnode=""><br></span></div><span data-trumbowyg-textnode="">In our research project <a href="http://www.highpermeshes.info/">HighPerMeshes</a>, physicists use them to simulate nanoantennas and interferences within different materials. Our goal is to provide them with a technology that enables the implementation of simulation codes in a simpler and more productive fashion, while at the same time allowing them to deploy to different target devices and accelerators.</span><br><br><span data-trumbowyg-textnode="">We decided to use SYCL to analyze and re-write a set of example code to solve Maxwell's equations because it allowed us to develop using standard C++, target a wide range of hardware, and gave us the opportunity to accelerate the code on this hardware.</span><br><br><span data-trumbowyg-textnode="">To make the complex structures more like those in the real-world, we use unstructured meshes made up of tetrahedrons. As a drawback, unstructured meshes require irregular memory accesses and this makes them harder to program and parallelize than, for example, stencil codes on regular grids. As the numerical method, we use the Discontinuous Galerkin (DG) method in which each tetrahedron carries a number of so-called nodal points that are the basis for all computations. One advantage of the DG method is that computations can be done in parallel for all the nodal points. However, since the nodal points refer to physical coordinates, one correction step is required where values of corresponding nodal points are normalized using the so-called numerical flux. For the time integration, we use a fourth order, five stages low-storage Runge-Kutta scheme that has proven to be very efficient for this class of application, meaning computations need to be done five times per time step.</span><br><br><span data-trumbowyg-textnode="">Starting from the original C code, we removed all references to external libraries used for handling of the mesh, including MPI used for parallelization. The original code consisted of three kernels to compute the numerical flux and the equation system's right-hand side on the surface of each mesh element, then inside each element, and finally to do the Runge-Kutta time integration step. We fused the two kernels that deal with the flux to make use of the data locality.</span><br><br><div><span data-trumbowyg-textnode="">The next step was to recover the semantics of computations. We replaced scalar variables that, for example represented three-dimensional vectors, with appropriate types. Additionally, these types feature overloaded mathematical operators and functions and this allowed us to represent coordinates and vector-valued data much more intuitively, e.g.:</span></div><div><span data-trumbowyg-textnode=""><br></span></div><div><pre><span data-trumbowyg-textnode="">// buffer for coordinates of nodal points per mesh element<br>cl::sycl::buffer&lt;coord_t, 2&gt; b_node_coords(cl::sycl::range&lt;2&gt;mesh_elements, nodal_points_per_element);<br><br>// buffers for magnetical and electrical fields for nodal points per element<br>cl::sycl::buffer&lt;real3_t, 2&gt; b_H(cl::sycl::range&lt;2&gt;mesh_elements, nodal_points_per_element);<br>cl::sycl::buffer&lt;real3_t, 2&gt; b_E(cl::sycl::range&lt;2&gt;mesh_elements, nodal_points_per_element);</span><br></pre></div><span data-trumbowyg-textnode=""></span><br><span data-trumbowyg-textnode="">Additionally, we can have short and meaningful expressions in our code, such as</span><br><pre>real3_t const fluxH = dH - dot_product(normal, dH) * normal - cross_product(normal, dE);<br>real3_t const fluxE = dE - dot_product(normal, dE) * normal + cross_product(normal, dH);<br></pre><span data-trumbowyg-textnode=""></span><br><div><span data-trumbowyg-textnode="">Here, coord_t and real3_t are simply vectors of three doubles. A lot of geometrical information on the mesh is needed for the computations, e.g., neighborhood relations between elements and their faces for the exchange of the numerical flux. Naturally, we implemented the geometric data as SYCL buffers using our data types to use them inside the kernels. However, a large portion of this data has to be calculated first, as the mesh file only stores physical coordinates of vertices and a mapping from vertices to elements. This preparatory work does not need to be accelerated (in fact, it is hard to parallelize and the speedup gained is negligible), so we do this sequentially on the host CPU and only initialize and use the SYCL queue much later.</span></div><div><span data-trumbowyg-textnode=""><br></span></div><span data-trumbowyg-textnode="">So, the program's structure looks like the following:</span><br><pre>// declaration of SYCL buffers for mesh and data<br>// initialization of mesh data structures<br>// computation of neccessary mesh information and data initialization<br><br>#if defined USE_CPU<br>auto selector = cl::sycl::cpu_selector{};<br>#elif defined USE_GPU<br>auto selector = cl::sycl::gpu_selector{};<br>#endif<br>auto device = selector.select_device();<br><br>cl::sycl::queue queue(selector);<br>for (size_t timestep = 0; timestep &lt; timesteps; ++timestep) {<br>    for (size_t runge_kutta_stage = 1; runge_kutta_stage &lt;= 5; ++runge_kutta_stage) {<br>        queue.submit([&amp;](cl::sycl::handler &amp;cgh) {<br>            // accessors ...<br>            cgh.parallel_for&lt;class mw_surfacevolume&gt;(cl::sycl::nd_range&lt;1&gt;mesh_elements, 32, [=](cl::sycl::nd_item&lt;1&gt; itm) { ... });<br>        };<br>        queue.submit([&amp;](cl::sycl::handler &amp;cgh) {<br>            // accessors ...<br>            cgh.parallel_for&lt;class mw_rk&gt;(cl::sycl::nd_range&lt;1&gt;mesh_elements, 32, [=](cl::sycl::nd_item&lt;1&gt; itm) { ... });<br>        };<br>    }<br>}<br></pre><br><span data-trumbowyg-textnode="">Overall, our SYCL-based implementation is significantly shorter and much easier to read and understand than the original code, and consequently less prone to programming errors. Additionally, we are able to easily evaluate the code not only on standard CPUs, but also on GPUs. In this work, we focused on the programmability and portability aspect of SYCL and did not research any potential impact on performance improvements we can apply to our code. There are many optimizations possible, such as avoiding scattered memory operations caused by the array-of-structs memory layout we are currently using, and taking care that all buffers are properly aligned and padded, to improve memory access times. Furthermore, we need to check which optimizations need to be applied for GPUs.</span><br><br><div><span data-trumbowyg-textnode="">However, to simply get an impression of the resulting performance, we ran exactly the same code on a number of different devices, i.e., an Intel Core i7-6700, an Intel Xeon E5640, and a low-end NVIDIA GPU (GTX 745) for mesh sizes ranging from 72 to 10k elements.<br></span></div><div><img src="{{ '/assets/images/portal/article-images/79092e9039b95f1316af1662e4646667.jpg' | relative_url }}" width="668" height="461"></div><div><br></div><div>As a conclusion, we are very satisfied with how easy it was to implement the code with SYCL, but need to do further investigations on how to write performance-optimal code. If you are interested in reading a detailed explanation and discussion using software complexity metrics, please have a look at our <a href="https://cris.fau.de/converis/portal/Publication/200969642">published research paper</a>.<br><span data-trumbowyg-textnode=""></span></div><br>

