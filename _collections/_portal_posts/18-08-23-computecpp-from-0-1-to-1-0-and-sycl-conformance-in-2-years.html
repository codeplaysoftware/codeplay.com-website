---
id: 312
url: 08-23-18-computecpp-from-0-1-to-1-0-and-sycl-conformance-in-2-years
user_id: 653
date: 2018-08-23T14:41:01.7200Z
category: blogs
title: "ComputeCpp: From 0.1 to 1.0 and SYCL Conformance in 2 years"
showOnFrontPage: 0
views: 0
tags:
redirect_from:
  - /portal/08-23-18-computecpp-from-0-1-to-1-0-and-sycl-conformance-in-2-years
thumbnail: /assets/images/portal/article-images/b36301868d88e5ac10dfdb7288afb23d.jpg
layout: portal/portal-article-view
---
<br>
<p><img src="{{ '/assets/images/portal/article-images/5fe127bd489b17ce7612e4cd7fec7a31.png' | relative_url }}" width="256" height="256">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <img src="{{ '/assets/images/portal/article-images/b36301868d88e5ac10dfdb7288afb23d.jpg' | relative_url }}"></p>
<p>The SYCL team at Codeplay is celebrating a major milestone, one that we have been working towards for quite a few years, and we can proudly and officially say <strong>"ComputeCpp is now a SYCL 1.2.1 conformant product for OpenCL 1.2 Ubuntu 16.04 platforms."</strong></p>If you are not familiar with the Khronos conformance process, an implementation must pass the entirety of the "Conformance Test Suite" (CTS) for a given specification before they can claim to implement the standard. The CTS is a comprehensive set of the language API and features, ensuring that everything defined by the specification is covered by the implementation. So Codeplay's ComputeCpp officially offers a mature product that allows developers to build on a stable API for their SYCL development.<br><br><h3>A SYCL History Lesson</h3>
<p>SYCL started as the "High Level Model for OpenCL" (HLM for OpenCL) around 2010 when the OpenCL working group was looking to develop a higher level interface that would make it easier for developers to target OpenCL devices. Various companies, including Codeplay, joined a sub-group (called HLM at the time) to discuss how this could be achieved. At that time the goal for HLM was to provide a "High-level programming model, unifying host and device execution environments through language syntax for increased usability and broader optimization opportunities." There was a desire to proliferate the use of OpenCL through a higher level development model.<br><br>Codeplay had been working on the latest version of "Offload", a product for games developers that included a way to make use of OpenCL through a C++ interface abstraction and was shipped in AAA video games, and the team were able to leverage that experience to contribute to the HLM working group. The group worked on various different ideas and models, until May 2015, when the first specification of what would end up being called SYCL (v1.2) was released. Codeplay launched an evaluator program that provided frequent releases of a prototype implementation to a select group of developers and that in turn enabled the group to receive feedback from developers who were using the SYCL APIs. With the development of ComputeCpp, Codeplay started participating in, and contributing to, multiple open-source projects. Codeplay actively contributes to the linear algebra library Eigen and machine learning framework TensorFlow, enabling large C++ applications to run on different types of accelerators. Contributions to the C++ Standard also began, with feedback and prototypes for features that affect heterogeneous and parallel architectures as the initial focus. One internal prototype was later open-sourced as the SYCL Parallel STL: an implementation of the C++17 parallel algorithms, using SYCL execution policies to accelerate execution on various heterogeneous platforms.<br><br>After the evaluation version gained enough maturity, Codeplay released the first public version of ComputeCpp in September 2016. ComputeCpp Community Edition 0.1 launched together with support for Eigen, Tensorflow, SYCL-BLAS, and SYCL Parallel STL on the same day. As we moved forward converting the internal prototype into a product, we created a release plan and scheduled features and fixes, and came up with a system that allows us to deploy a new release of ComputeCpp every month. If a user had an issue with a given release, we would try to do our best to resolve it in one of the upcoming releases. This quick turnaround and feedback significantly improved our ability to create and propose new features to the standard and, in general, improve the implementation of the SYCL run-time and compiler. The regular releases also allowed developers of the SYCL ecosystem projects to work faster since they are not blocked if a particular issue affects one release, they only have to wait for the next one to have a fix.<br><br>The feedback from developers was fed back to the SYCL working group, and since the 2015 release we have worked internally to process all the feedback and make the necessary changes to the specification, adding new features and fixing those problems that were reported. This process concluded in the last quarter of 2017, when the SYCL group ratified the version 1.2.1 of the specification, and made this public in December 2017. ComputeCpp 0.5.1 implemented the updated SYCL 1.2.1 specification on the day of the release, since it had been used for prototyping by the group in parallel with the development.<br><br>During 2018, the SYCL team at Codeplay has been working to complete the API implementation, find all corner cases, and actively contributes to the Khronos SYCL CTS, which, as discussed earlier, is used for conformance.</p><strong>ComputeCpp now enables C++ developers to accelerate their code on a wide range of processors from companies including AMD, Intel, Arm and Renesas.<br></strong>
<p><strong><br></strong></p>
<p></p><h3>How I got involved with SYCL and ComputeCpp</h3><span data-trumbowyg-textnode="">I started at Codeplay in 2013 as a 'Research Compiler Engineer'. Shortly after destiny called with some detours on the way (CMake, Jenkins and even Android!), and I eventually settled on being a run-time developer/designer and contributor to the SYCL specification, up until August 2016. After version 0.1 of ComputeCpp, the first externally available release, I took overturning this prototype into a product and became 'Product Lead' of ComputeCpp. I led the team and the contributions to the SYCL specification, with the goal of converting the prototype into a stable product (and programming model) that developers can rely on when designing their applications. I spend most of my days working with the run-time, compiler, and specification teams; reviewing documentation, code patches, and dealing with unusual corner cases on one (or all) of them. I am also lucky to work with colleagues Andrew Richards, Alistair Low, and Michael Wong on setting the roadmap for our SYCL products, ensuring it keeps being your preferred choice for programming accelerators using C++.</span><br><br>
<p></p><h3>The People That Have Made History</h3>The list of people that have contributed towards this ComputeCpp 1.0 release over the years is long, and due to GDPR rules I am unable to list those people no longer at the company. However I am sure you know who you are, and we are grateful for your efforts!<br>
<p><br>I spent some time looking through the commit logs for the various project repositories to see the contributions over the years and would like to give a shout out to those who are still working at Codeplay to say thank you for their hard work on ComputeCpp in its different iterations.<br><br>The current ComputeCpp compiler can trace its roots back to Uwe, who adapted the implementation of 'Offload' in 2012, and in the same year the run-time repository saw its first commit from Andrew, our CEO.<br><br>Gordon joined the project shortly after Uwe's and Andrew's initial commits, and today he is a 'Senior Software Engineer' in the ComputeCpp team. He was the person responsible for delivering the CTS testing and specification changes in the 'final push' to complete our run-time and gain conformance.<br><br>Peter joined the team in 2016 and started working straight away on the run-time implementation. He is now leading most of the run-time work and reviewing all merge requests that affect the core run-time. Marios joined in 2017 and started working straight away on implementing SYCL features for the run-time, and has made several bug fixes and design changes on the run-time to accommodate key new features. Graham, our 'Release Manager', joined us in the same year and made sure we now have a very smooth release process, and has significantly improved our lives by handling the relationship with the different open source projects that depend on ComputeCpp. He also helped develop our infrastructure and Jenkins integration improving our continuous integration and testing. Another new team member that year was Chris, who joined us to help develop our integration with the main C++ Standard, and has contributed several proposals and new ideas for SYCL and C++. He is now our local 'post-modern C++ advocate'.<br><br>On the compiler side of ComputeCpp, Victor joined the team in 2015 and led many core changes in the compiler to make it more flexible. He is now our SYCL compiler 'overlord', and spends his days reviewing all the merge requests for the compiler as well mentoring newcomers into the amazing world of compilers. Stephen joined Codeplay in 2014, but only joined the ComputeCpp team in May 2016, after finishing his university degree. He started to work on the compiler by hunting down several bugs from the maze that can be Clang, and has contributed to the various device-specific back-ends for ComputeCpp. Alexander joined in 2017 to work on the compiler but quickly jumped to help everyone on the run-time and the CTS implementation. He has been involved in various aspects of the runtime and testing suites, but has now re-focused on compiler work.<br><br>On the testing side of ComputeCpp, Panos joined the team in 2016 and worked on improving our testing framework for ComputeCpp to help us better track issues that were reported by users and also contributed to the SYCL specification and CTS.<br><br>Several other people at Codeplay have also contributed to SYCL and ComputeCpp: Verena, Ralph, Duncan, Jakub, Floyd, Pierre-Andre, Simon, Meenakshi, Luke, Aidan, Deepak, and Morris. There has also been a long list of interns and people no longer at the company over that have contributed over the years, and we thank them all for their hard work!<br><br>Finally, nothing would have been possible without the support of our infrastructure team that Aaron has been directing for a long time, dealing with all of our hardware requirements and needs.</p><br>
<p></p><h3>The Future for SYCL and ComputeCpp</h3>ComputeCpp and SYCL continue to evolve. We have created a stable API for C++ developers to work on, and now we can focus on improving performance and delivering new features. The run-time and compiler are undergoing a series of enhancements with improvements to performance and a reduction in the overhead on various platforms. Our main focus right now is on embedded devices, you can read our <a href="https://www.codeplay.com/portal/12-09-17-open-standard-software-frameworks-facilitate-development-using-renesas-rcar-socs">announcement with Renesas</a>, but we keep analyzing and maintaining the performance of machine learning applications running on desktop and mobile GPUs. This is driven by all the feedback we receive from our, now fairly large, community of developers.<br>
<p><br>There are new features coming in upcoming releases that will deliver more functionality and enable use of&nbsp; additional hardware features. We aim for most of these features to be included in upcoming versions of SYCL, but first we want to get feedback from users to see if they satisfy their requirements. If you want to be clued in on what is coming, take a look at the <a href="http://www.github.com/codeplaysoftware/standards-proposals/">Codeplay Standards and Proposals repository</a>, where SYCL and C++ proposals are posted whenever there is a public update on the work.<br><br>We also continue to collaborate with the C++ Standard in different parallelism proposals, such as the C++ executors, futures, execution contexts, and affinity. We hope this collaboration will result in even closer ties between SYCL and C++, and further benefits for all C++ developers.<br><br><br>If you want to provide feedback on the SYCL specification or ComputeCpp you can get in touch with us at sycl<img class="email-at-symbol" src="{{ '/assets/images/global/at-symbol.svg' | relative_url }}" />codeplay.com.<br></p>
<p></p>
<p></p>
<p></p><strong><span data-trumbowyg-textnode=""></span></strong>
<p></p><br>

