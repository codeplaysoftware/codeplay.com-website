---
id: 349
url: 07-12-19-enabling-polymorphism-in-sycl-using-the-cpp-idiom-crtp
user_id: 852
date: 2019-07-12T14:57:57.7200Z
category: blogs
title: "Enabling Polymorphism in SYCL using the C++ idiom CRTP"
showOnFrontPage: 0
views: 0
tags:
redirect_from:
  - /portal/07-12-19-enabling-polymorphism-in-sycl-using-the-cpp-idiom-crtp
layout: portal/portal-article-view
thumbnail: /assets/images/portal/no-thumbnail-placeholder.png
---
<h3>Introduction</h3>
<p>Dynamic polymorphism is a widely used C++ feature that allows code to be more flexible, and helps create easily extendable interfaces by <strong>overriding</strong> the base class specified interfaces inside our derived classes. However, in SYCL kernel code in order to emulate dynamic polymorphism we need to use some curious tricks and techniques.</p><h3>Introducing Curiously Recurring Template Pattern (CRTP)</h3>
<p>The CRTP idiom offers an alternative approach to polymorphism by providing us with the ability to specify static interfaces, where the base class specifies the the structure of the interface, while the derived one represents the implementation. In this case, the base class does represent the interface and the derived class represents the implementation — similar to the general idea of polymorphism. However, the difference in comparison to dynamic (traditional) polymorphism is that there is no virtual involved. Under the hood, all calls are resolved at compile-time. Another difference that occurs with all instances of using template code is that we cannot split the classes declarations and implementations between .h and .cpp files, therefore kernel code can only be split into header files.</p>
<p>CRTP is composed of:<br></p><ul><li>Inheriting from a template class</li><li>Using the derived class itself as a template parameter of the base class</li></ul><br>
<p>One particular use of CRTP we are going to look into is a way to achieve a polymorphic-like behavior by avoiding traditional dynamic polymorphism.</p><h3>An Example of Polymorphism Using CRTP</h3>
<p>Let's look at how this can be implemented in generic C++ code.</p>
<p>This code snippet shows a simple interface that can be used to define mathematical function operations - filters that process numbers (e.g., Linear function).</p><pre><code>template &lt;typename DerivedFilter&gt;<br><br>struct BaseFilter {<br><br>  template &lt;typename T&gt;<br><br>  void process(T&amp; number) const {<br><br>    const auto&amp; underlying = static_cast&lt;const DerivedFilter&amp;&gt;(*this);<br><br>    return underlying.template process(number);<br><br>  }<br><br>};<br></code></pre><br>
<p>The <code>process</code> function will be able to apply the filtering operation numbers of any (numerical) type. It is defined as <code>const</code> and expects the derived class that implements it is a <code>const</code> object as we are casting to <code>const</code> <code>DerivedFilter&amp;</code>. The reason behind this choice is that we won't be modifying any internal members of the filter objects through that function so we keep it read-only. However, you are not bound to this and can cast the underlying object as a reference instead.</p>
<p>Say we have two implementations for this interface to process a number: One does it by implementing a <code>linear function</code>, and the other through a <code>sigmoid function</code>. These two implementations inherit from the <code>BaseFilter</code> base class we call the interface.</p>
<p>The first specialization we define is <code>LinearFilter</code> specialization (applies a <code>linear function</code>).</p><pre><code>template &lt;typename U&gt;<br><br>struct LinearFilter : public BaseFilter&lt;LinearFilter&lt;U&gt;&gt; {<br><br>  LinearFilter() = default;<br><br>  explicit LinearFilter(U a_, U b_) : a(a_), b(b_) {}<br> <br><br>  template &lt;typename T&gt;<br><br>  void process(T&amp; number) const {<br><br>    auto x = number;<br><br>    auto fx = a + b * x;<br><br>    number = fx;<br><br>  }<br> <br><br>  U a, b;<br><br>};<br></code></pre><br>
<p>In this definition, we also template the class to allow specifying a type for the a and b members that may not necessarily the same as the number to process.</p>
<p>Now let's define the <code>SCurveFilter</code> specialization (applies a <code>logistic sigmoid function</code>).</p><pre><code>struct SCurveFilter : public BaseFilter&lt;SCurveFilter&gt; {<br><br>  SCurveFilter() = default;<br> <br><br>  template &lt;typename T&gt;<br><br>  void process(T&amp; number) const {<br><br>    auto x = number;<br><br>    auto ex = exp(-x);<br><br>    auto fx = 1 / (1 + ex);<br><br>    number = fx;<br><br>  }<br><br>};&nbsp; </code></pre><br>
<p>The code snippets above present a polymorphic class structure via CRTP , referred to as <strong>static polymorphism</strong>. The base class - <code>BaseFilter</code>, is designed to be inherited from by its <strong>template parameter</strong>, and by <strong>nothing else</strong>. Therefore, it takes this as an assumption, and a <code>static_cast</code> is enough&nbsp; to convert to the correct derived type.</p>
<p>However, we can further inherit to provide specialization of <code>SCurveFilter</code>, for example, for <code>SmoothstepFilter.&nbsp;</code> In general, this translates to <code>class Derived1 -&gt; class Base</code>, where we have a child class derived from the base class interface and&nbsp; <code>class Derived2 -&gt; class Derived1</code>, where we have a second child class derived from the first child class. This could lead to increased complexity and ambiguity in situations referred as the diamond problem, where it may be unclear as to which parent class a particular feature is inherited from if more than one parent class implements it. In this case things can go as wrong as undefined behavior, when using the CRTP method. Fortunately, this can be prevented by using a technique suggested in a Jonathan Boccara's (FluentCpp) <a href="https://www.fluentcpp.com/2017/05/12/curiously-recurring-template-pattern/">blog post</a> several years ago. This blog is also a great resource on writing expressive, clean, and less error prone C++, including more essential information on CRTP. The author's way around the diamond problem is to add a private constructor in the base class and make the base class friend with the template derived class.</p><h3>Using CRTP in C++</h3>
<p>In order to create a generic function that modifies each number of the array by applying any of the defined filters that specialize the base interface class the following code is used:</p><pre><code>template &lt;typename T, typename Filter&gt;<br><br>void process_numbers(std::vector&lt;T&gt;&amp; numbers, const BaseFilter&lt;Filter&gt;&amp; filter) {<br><br>  for (auto&amp; number : numbers) {<br><br>    filter.template process(number);<br><br>  }<br><br>}&nbsp;&nbsp; </code></pre>
<p>Now it starts to look more like a standard definition for polymorphism only that it is achieved through the use of type templates with standard member functions rather than virtual ones - as you can see there are no virtual calls present in the code.</p>
<p>As a result, we still get the generic behavior we need and we are confident we can use the same techniques within our SYCL code as well.</p>
<p>Finally, here is how we can use either of the generic process_numbers function implementations in a C++ application, for any of the implemented <code>Filter</code> types.</p><pre><code>std::vector&lt;float&gt; numbers(32);<br><br>generate_random_uniform_values(numbers)<br> <br><br>auto filters = std::make_pair(LinearFilter&lt;int&gt;{1, 5}, SCurveFilter{});<br> <br><br>process_numbers(numbers, filters.first);<br><br>process_numbers(numbers, filters.second);<br></code></pre>
<p>We define the filter types as a pair (auto filters) since we only have two derived implementations of the base filter interface. It is very flexible that our <code>Linear</code> filter being a template class can be passed the same way as our <code>SCurve</code> filter that is not a template class because when process_numbers is invoked, the compiler will replace the typename Filter with the concrete types, in our case: <code>Linear&lt;int&gt;</code> and <code>Scurve</code>. Therefore, we just call them by <code>process_numbers</code> with the numbers array and filter object as arguments.</p><h3>Using CRTP in SYCL</h3>
<p>We talked about how this can be used with SYCL kernels to achieve the equivalent of traditional polymorphism, so let’s take the C++ program we have developed and show how it can be used with SYCL.</p>
<p>Here is our kernel function object definition where to access</p><pre><code>template &lt;typename T, class Filter&gt;<br><br>class process_numbers_kernel {<br><br>  static constexpr auto read_mode = access::mode::read;<br><br>  static constexpr auto write_mode = access::mode::write;<br><br>  static constexpr auto target = access::target::global_buffer;<br> <br><br> public:<br><br>  process_numbers_kernel(accessor&lt;Filter, 1, read_mode, target&gt; filter_acc,<br><br>                         accessor&lt;T, 1, write_mode, target&gt; numbers_acc)<br><br>      : m_filter_acc(filter_acc), m_numbers_acc(numbers_acc) {}<br> <br><br>  void operator()(nd_item&lt;1&gt; item) {<br><br>    auto id = item.get_global_id(0);<br> <br><br>    auto filter = m_filter_acc.get_pointer();<br><br>    auto number = m_numbers_acc[id];<br> <br><br>    filter-&gt;process(number);<br> <br><br>    m_numbers_acc[id] = number;<br><br>  }<br> <br><br> private:<br><br>  accessor&lt;Filter, 1, read_mode, target&gt; m_filter_acc;<br><br>  accessor&lt;T, 1, write_mode, target&gt; m_numbers_acc;<br><br>};<br></code></pre>
<p>We need to be able to create a <code>sycl::buffer</code> of the right type from our class inheritance system. The following function definition of <code>process_numbers</code> demonstrates one way to go about it.</p><pre><code>template &lt;typename T, class Filter&gt;<br><br>void process_numbers(std::vector&lt;T&gt;&amp; numbers, const BaseFilter&lt;Filter&gt;&amp; filter) {<br><br>  auto filter_buf = buffer&lt;Filter, 1&gt;(&amp;static_cast&lt;const Filter&amp;&gt;(filter), range&lt;1&gt;(1));<br><br>  auto numbers_buf = buffer&lt;float, 1&gt;(numbers.data(), range&lt;1&gt;(numbers.size()));<br> <br><br>  static queue device_queue(default_selector{});<br><br>  device_queue.submit([&amp;](handler&amp; cgh) {<br><br>    auto filter_acc = filter_buf.template get_access&lt;access::mode::read&gt;(cgh);<br><br>    auto numbers_acc = numbers_buf.get_access&lt;access::mode::write&gt;(cgh);<br>    <br><br>    &lt;&lt;&lt; Execute the kernel &gt;&gt;&gt;<br><br>  });<br><br>}<br></code></pre>
<p>The filter buffer is created using <code>static_cast&lt;const Filter&amp;&gt;(filter)</code> so we can get the filter object's exact type - the derived specialization, otherwise we will get this: <code>BaseFilter &lt; Some Derived Filter Type &gt;</code> which is not going to compile in SYCL.</p>
<p>The SYCL compiler will throw the following error in the buffer class:</p><pre><code>cannot convert from base class pointer 'BaseFilter&lt;SomeDerivedFilter&gt;' to derived class pointer 'SomeDerivedFilter'<br></code></pre>
<p>However, if you wish to avoid casting you can simply change the parameter type of the filter in the <code>process_numbers</code> function like so:</p><pre><code>template &lt;typename T, class Filter&gt;<br><br>void process_numbers(std::vector&lt;T&gt;&amp; numbers, const Filter&amp; filter) {<br><br>    auto filter_buf = buffer&lt;Filter, 1&gt;(&amp;filter, range&lt;1&gt;(1));<br>    <br><br>    ...<br><br>}<br></code></pre>
<p>And you can see that it is no more required to cast to the underlying type since it is automatically deduced via the template parameter.</p>
<p>Note that this approach does not explicitly specify that it should accept an object of type based on <code>BaseFilter</code> but you can easily perform some type checking or static assertion to be safe.</p>
<p>Now, to execute the kernel we will use the <code>sycl::parallel_for</code> function that will execute the kernel in parallel on a number of work-items (split between 4 work-groups in our definition) .</p><pre><code>auto index_space = nd_range&lt;1&gt;(range&lt;1&gt;(numbers.size()), range&lt;1&gt;(numbers.size() / 4));<br><br>auto kernel_func = kernels::process_numbers_kernel&lt;float, Filter&gt;(filter_acc, numbers_acc);<br><br>cgh.parallel_for(index_space, kernel_func);&nbsp;</code></pre>
<p>Finally, we call our calculate_area function the same exact way as we did with our C++ implementation.</p><pre><code>auto filters = std::make_pair(LinearFilter&lt;int&gt;{1, 5}, SCurveFilter{});<br> <br><br>process_numbers(numbers, filters.first);<br><br>process_numbers(numbers, filters.second);</code></pre>
<p>We have achieved a polymorphic behavior in SYCL kernels via the use of standard C++ templates, implementing the Curiously Recurring Template Pattern. This is one of the methods that are available to providing a working comparable solution to dynamic polymorphism inside SYCL kernel code. As mentioned in <a href="https://developer.codeplay.com/products/computecpp/ce/guides/sycl-guide/limitations">our guide</a>, type enumeration is also a solution to performing pseudo-virtual calls.</p><h3>Conclusion</h3>
<p>Generally, Curiously Recurring Template Pattern (CRTP) is a great pattern to simulate polymorphic behavior at compile-time, however, as everything else in life, nothing is truly perfect. Be aware of your class types beforehand, as this approach will not work in cases of unknown type hierarchy. The development of complex software applications in C++ will most likely require the use of polymorphism and in order to be able to accelerate these software using SYCL kernels, developers need to work around the limitation for using dynamic polymorphism rooting way back from OpenCL. Through CRTP we can have static polymorphic interfaces that are accepted in SYCL kernel code and ultimately, still achieve the goal of designing a polymorphic system.</p>
<p>If you want to dive deeper into CRTP, you can also have a look at this <a href="https://www.fluentcpp.com/2017/05/19/crtp-helper/">set of blog posts</a> by Jonathan Boccara.</p><br>
<p><style>li.L1,li.L3,li.L5,li.L7,li.L9{background:inherit}</style></p>

